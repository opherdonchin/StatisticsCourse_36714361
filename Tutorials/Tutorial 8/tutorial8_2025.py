# -*- coding: utf-8 -*-
"""Tutorial8_2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q3TGekFPNnHh4Qe0P7Hs_G7Xs8YSIMIJ

# **Tutorial 8**

### Imports
"""

import numpy as np # arrays, array operations
import scipy.stats as stats # statistics
from google.colab import files
import matplotlib.pyplot as plt # plot graphs
import pandas as pd #dataframes
import io
import xarray as xr #multidimensional dataframes
import pymc as pm
import arviz as az
import seaborn as sns
import scipy.interpolate as interpolate

#preliz
!pip install preliz
import preliz as pz

"""### Water Contamination Example - Hierarchical Model"""

#creating data
N_samples = [30, 30, 30]
G_samples = [18, 18, 18]
group_idx = np.repeat(np.arange(len(N_samples)), N_samples)
data = []
for i in range(0, len(N_samples)):
  data.extend(np.repeat([1, 0], [G_samples[i], N_samples[i]-G_samples[i]]))

"""Model 1"""

coords = {"neighborhood": np.arange(len(N_samples)), "neighborhood_data": group_idx}

with pm.Model(coords = coords) as model_h1:
  # hypyerpriors
  mu = pm.Beta('mu', 1, 1)
  nu = pm.HalfNormal('nu', 10)
  # prior
  theta = pm.Beta('theta', mu=mu, nu=nu, dims = "neighborhood")
  # likelihood
  y = pm.Bernoulli('y', p=theta[group_idx], observed = data, dims = "neighborhood_data")

  idata_h1 = pm.sample(1000, chains = 4)

"""Posterior"""

#trace data
az.plot_trace(idata_h1, compact = False)
plt.subplots_adjust(hspace=0.6)  # Increase spacing between subplots

plt.savefig("tracegroup.png", bbox_inches='tight')
files.download("tracegroup.png")

#hdi and mean
az.plot_posterior(idata_h1, var_names=["theta"])

plt.savefig("hdi1.png", bbox_inches='tight')
files.download("hdi1.png")

"""Shrinkage"""

#running two additional models
#new data for each one
N_samples = [30, 30, 30]
G_samples = [3, 3, 3]
group_idx = np.repeat(np.arange(len(N_samples)), N_samples)
data = []
for i in range(0, len(N_samples)):
  data.extend(np.repeat([1, 0], [G_samples[i], N_samples[i]-G_samples[i]]))

with pm.Model(coords = coords) as model_h2:
  # hypyerpriors
  mu = pm.Beta('mu', 1, 1)
  nu = pm.HalfNormal('nu', 10)
  # prior
  theta = pm.Beta('theta', mu=mu, nu=nu, dims = "neighborhood")
  # likelihood
  y = pm.Bernoulli('y', p=theta[group_idx], observed = data, dims = "neighborhood_data")

  idata_h2 = pm.sample(1000, chains = 4)

#trace data
az.plot_trace(idata_h2, compact = False)
plt.subplots_adjust(hspace=0.6)  # Increase spacing between subplots

plt.savefig("tracegroup2.png", bbox_inches='tight')
files.download("tracegroup2.png")

#hdi and mean
az.plot_posterior(idata_h2, var_names=["theta"])

plt.savefig("hdi2.png", bbox_inches='tight')
files.download("hdi2.png")

#last one
N_samples = [30, 30, 30]
G_samples = [3, 3, 18]
group_idx = np.repeat(np.arange(len(N_samples)), N_samples)
data = []
for i in range(0, len(N_samples)):
  data.extend(np.repeat([1, 0], [G_samples[i], N_samples[i]-G_samples[i]]))

with pm.Model(coords = coords) as model_h3:
  # hypyerpriors
  mu = pm.Beta('mu', 1, 1)
  nu = pm.HalfNormal('nu', 10)
  # prior
  theta = pm.Beta('theta', mu=mu, nu=nu, dims = "neighborhood")
  # likelihood
  y = pm.Bernoulli('y', p=theta[group_idx], observed = data, dims = "neighborhood_data")

  idata_h3 = pm.sample(1000, chains = 4)

#trace data
az.plot_trace(idata_h3, compact = False)
plt.subplots_adjust(hspace=0.6)  # Increase spacing between subplots

plt.savefig("tracegroup3.png", bbox_inches='tight')
files.download("tracegroup3.png")

#hdi and mean
az.plot_posterior(idata_h3, var_names=["theta"])

plt.savefig("hdi3.png", bbox_inches='tight')
files.download("hdi3.png")

"""### Multiple Regression

#### Loading and Setting Up Data

Loading data
"""

import urllib.request
urllib.request.urlretrieve('https://raw.githubusercontent.com/BayesianModelingandComputationInPython/BookCode_Edition1/main/exercises/data/radon.csv','radon.csv')

radon = pd.read_csv('radon.csv')
radon

"""Extract data from the table"""

radon_know_b = radon[radon["basement"].isin(["Y","N"])] #only get rows with all the necessary data
b = radon_know_b["basement"]
b_idx,b_codes = pd.factorize(b)
r = radon_know_b["log_radon"] #the level of randon

#so b is yes or no basement, and r is the level of randon in each case

#look at the data
plt.hist(r[b == 'Y'], color = 'pink', label = 'Yes Basement')
plt.hist(r[b == 'N'], color = 'blue', label = 'No Basement')
plt.legend()
plt.xlabel('log radon')
plt.ylabel('counts')

plt.savefig("data.png", bbox_inches='tight')
files.download("data.png")

"""#### Creating Model

Priors
"""

# Parameters for normal prior for β_0, the intercept
μ_0 = np.mean(r)
σ_0 = np.std(r)
# Parameter for zero-centered normal prior for β_b, the effect of having a basement
σ_b = np.std(r)
# Parameters for gamma prior for σ_r, the unnexplained noise
μ_σ_r = np.std(r)
σ_σ_r = np.std(r)/2

"""Model"""

c_basement = {"basement": b_codes, "data": np.arange(len(r))}

with pm.Model(coords=c_basement) as m_basement:
  b_i = pm.Data('b_i', b_idx, dims="data")

  β_0 = pm.Normal('β_0', mu=μ_0, sigma=σ_0)
  β_b = pm.Normal('β_b', mu=0, sigma=σ_b, dims="basement")

  μ_r = pm.Deterministic('μ_r', β_0 + β_b[b_i], dims="data")
  σ_r = pm.Gamma('σ_r', mu=μ_σ_r, sigma=σ_σ_r)
  r_obs = pm.Normal('r_obs', mu=μ_r, sigma=σ_r, observed=r, dims="data")

"""#### Prior Predictive Checks"""

id_basement = pm.sample_prior_predictive(model=m_basement)
az.plot_ppc(id_basement, group="prior",  observed=True)

plt.savefig("ppc.png", bbox_inches='tight')
files.download("ppc.png")

"""#### Sample

"""

id_basement.extend(
    pm.sample(draws=1000, chains=4, model=m_basement)
)

id_basement

"""Examining the Posterior and Diagnostics"""

az.plot_trace(id_basement, var_names = ["β_0", "β_b", "σ_r"], compact = False)
plt.subplots_adjust(hspace=0.8)  # Increase spacing between subplots

plt.savefig("trace.png", bbox_inches='tight')
files.download("trace.png")

#plotting the posterior with the HDI
az.plot_posterior(id_basement, var_names = ["β_0", "β_b", "σ_r"])

plt.savefig("hdi.png", bbox_inches='tight')
files.download("hdi.png")

az.summary(id_basement, kind="diagnostics", var_names=["β_0", "β_b", "σ_r"])

"""#### Posterior Predictive"""

pm.sample_posterior_predictive(id_basement, model=m_basement, extend_inferencedata=True)
az.plot_ppc(id_basement, num_pp_samples=100)

plt.savefig("ppc2.png", bbox_inches='tight')
files.download("ppc2.png")

"""#### Posterior Inference"""

id_basement.posterior["μ_b"] = id_basement.posterior.β_0 + id_basement.posterior.β_b

az.plot_posterior(id_basement, var_names=["μ_b"])
plt.savefig("basementmean.png", bbox_inches='tight')
files.download("basementmean.png")

#cohen's d
cohen_d = (id_basement.posterior.sel(basement='Y').μ_b - id_basement.posterior.sel(basement='N').μ_b) / id_basement.posterior.σ_r
az.plot_posterior(cohen_d)
plt.savefig("d.png", bbox_inches='tight')
files.download("d.png")

"""#### Adding County Data

Getting the data
"""

c = radon_know_b["county"]
c_idx,c_codes = pd.factorize(c)

"""Examining"""

ax = sns.stripplot(x=b, y=r, hue=c, dodge=True, jitter=False)
ax.axvline(0.5)
plt.legend([],[], frameon=False)
plt.savefig("countydata.png", bbox_inches='tight')
files.download("countydata.png")

"""##### Priors"""

# Looking at the data above, difference between counties could be as much as 1
μ_σ_c = 1
σ_σ_c = 0.8

"""##### Model - Not Heirarchical"""

c_county = {"basement": b_codes, "county": c_codes, "data": np.arange(len(r))}

with pm.Model(coords=c_county) as m_county1:
  b_i = pm.Data('b_i', b_idx, dims="data")
  c_i = pm.Data('c_i', c_idx, dims="data")

  β_0 = pm.Normal('β_0', mu=μ_0, sigma=σ_0)
  β_b = pm.Normal('β_b', mu=0, sigma=σ_b, dims="basement")
  β_c = pm.Normal('β_c', mu=0, sigma=μ_σ_c, dims="county")

  μ_r = pm.Deterministic('μ_r', β_0 + β_c[c_i] + β_b[b_i], dims="data")
  σ_r = pm.Gamma('σ_r', mu=μ_σ_r, sigma=σ_σ_r)
  r_obs = pm.Normal('r_obs', mu=μ_r, sigma=σ_r, observed=r, dims="data")

"""##### Prior Predictive Check"""

id_county = pm.sample_prior_predictive(model=m_county1)
az.plot_ppc(id_county, group="prior", observed = True)

"""##### Sample and Diagnostics"""

id_county.extend(
    pm.sample(draws=1000, chains=4, model=m_county1)
)
id_county

az.summary(id_county, kind="diagnostics", var_names= ["β_0", "β_b", "β_c", "σ_r"] )

az.plot_trace(id_county, var_names=["β_0", "β_b", "β_c", "σ_r"])
plt.savefig("kde2.png", bbox_inches='tight')
files.download("kde2.png")

"""##### Posterior Predictive"""

pm.sample_posterior_predictive(id_county, model=m_county1, extend_inferencedata=True)
az.plot_ppc(id_county, num_pp_samples=100)
plt.savefig("ppc4.png", bbox_inches='tight')
files.download("ppc4.png")

"""##### Posterior Inference"""

r_c = radon_know_b.groupby("county")["log_radon"].mean()
post = id_county.posterior
post["μ_c"] = post.β_0 + post.β_c #+ post.β_b.sel(basement = 'Y')
post["μ_b"] = post.β_0 + post.β_b

sorted_indices = np.argsort(r_c.values)
a = post["μ_c"].isel(county = sorted_indices)
az.plot_lm(y=r_c[sorted_indices], x=np.arange(len(r_c)), y_model=a, kind_model="hdi", kind_pp="hdi", y_model_mean_kwargs={"linestyle": "none", "marker": "o"})
plt.xlabel('Counties Sorted by Radon Level')
plt.savefig("lm.png", bbox_inches='tight')
files.download("lm.png")

"""##### Effect of Basement"""

az.plot_posterior(id_county, var_names=["μ_b"])
plt.savefig("b.png", bbox_inches='tight')
files.download("b.png")

"""#### Hierarchical Model"""

c_county = {"basement": b_codes, "county": c_codes, "data": np.arange(len(r))}

with pm.Model(coords=c_county) as m_county:
  b_i = pm.Data('b_i', b_idx, dims="data")
  c_i = pm.Data('c_i', c_idx, dims="data")

  σ_c = pm.Gamma('σ_c', mu=μ_σ_c, sigma=σ_σ_c)

  β_0 = pm.Normal('β_0', mu=μ_0, sigma=σ_0)
  β_b = pm.Normal('β_b', mu=0, sigma=σ_b, dims="basement")
  β_c = pm.Normal('β_c', mu=0, sigma=σ_c, dims="county")

  μ_r = pm.Deterministic('μ_r', β_0 + β_c[c_i] + β_b[b_i], dims="data")
  σ_r = pm.Gamma('σ_r', mu=μ_σ_r, sigma=σ_σ_r)
  r_obs = pm.Normal('r_obs', mu=μ_r, sigma=σ_r, observed=r, dims="data")

"""##### Prior Predictive Checks"""

id_county = pm.sample_prior_predictive(model=m_county)
az.plot_ppc(id_county, group="prior", observed = True)

"""##### Sample and Diagnostics"""

id_county.extend(
    pm.sample(draws=1000, chains=4, model=m_county)
)
id_county

az.summary(id_county, kind="diagnostics", var_names= ["β_0", "β_b", "β_c", "σ_c", "σ_r"] )

az.plot_trace(id_county, var_names=["β_0", "β_b", "β_c", "σ_c", "σ_r"])
plt.savefig("kde.png", bbox_inches='tight')
files.download("kde.png")

"""##### Posterior Predictive"""

pm.sample_posterior_predictive(id_county, model=m_county, extend_inferencedata=True)
az.plot_ppc(id_county, num_pp_samples=100)
plt.savefig("ppc3.png", bbox_inches='tight')
files.download("ppc3.png")

"""##### Posterior Inference

Effect of Hierarchical Model
"""

r_c = radon_know_b.groupby("county")["log_radon"].mean()
post = id_county.posterior
post["μ_c"] = post.β_0 + post.β_c
post["μ_b"] = post.β_0 + post.β_b

sorted_indices = np.argsort(r_c.values)
a = post["μ_c"].isel(county = sorted_indices)
az.plot_lm(y=r_c[sorted_indices], x=np.arange(len(r_c)), y_model=a, kind_model="hdi", kind_pp="hdi", y_model_mean_kwargs={"linestyle": "none", "marker": "o"})
plt.xlabel('Counties Sorted by Radon Level')
plt.savefig("lm.png", bbox_inches='tight')
files.download("lm.png")

"""Effect of Basement"""

az.plot_posterior(id_county, var_names=["μ_b"])
plt.savefig("b.png", bbox_inches='tight')
files.download("b.png")